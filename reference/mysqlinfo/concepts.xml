<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<chapter xml:id="mysqlinfo.concepts" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Concepts</title>
 <para>
  These concepts are specific to the MySQL drivers for PHP.
 </para>

 <section xml:id="mysqlinfo.concepts.buffering">
  <title>Buffered and Unbuffered queries</title>
  
  <para>
   Queries are using the buffered mode by default. This means that query results are 
   immediately transfered from the MySQL Server to PHP in is then kept  in the memory
   of the PHP process. This allows additional operations like counting the
   number of rows, and moving (seeking) the current result pointer. It also allows
   issuing further queries on the same connection while working on the result set.
   The downside of the buffered mode is that larger result sets might require
   quite a lot memory. The memory will be kept occupied till all references to the
   result set are unset or the result set was explicitly freed, which will automatically
   happen during request end the latest. The terminology "store result" is also used
   for uffered mode, as the whole result set is stored at once.
  </para>

  <note>
   <para>
    When using libmysql as library PHP's memory limit won't count the memory used
    for result sets unless the data is fetched into PHP variables. With mysqlnd
    the memory accounted for will include the full result set.
   </para>
  </note>
  
  <para>
   Unbuffered MySQL queries execute the query and then return a <type>resource</type> while
   the data is still waiting on the MySQL server for being fetched. This uses less memory
   on the PHP-side, but can increase the load on the server. Unless the full result set was
   fetched from the server no further queries can be sent over the same connection. Unbuffered
   queries can alsoe refered to as "fetch result", as the rows are fetched on demand.
  </para>

  <para>
   Following these characteristics buffered queries should be used in cases where you expect
   only a limited result set or need to know the amount of returned rows before reading all
   rows. Unbuffered mode should be used when you expect larger results.
  </para>
  
  <!-- @TODO
    - Add list of issues people run into with unbuffered queries
    - Add list of specific use cases for when unbuffered queries are useful
    - Question: Unbuffered queries still require all rows to be returned or resource free before executing another? Applies to all extensions?
    - Show "free_result" functions / unset usage with buffered queries 8double-check with Andrey on mysqlnd optimizations
   -->
  
  <para>
   Because buffered queries are the default, the examples below will demonstrate how to
   execute unbuffered queries with each API.
  </para>

  <example>
   <title>Unbuffered query example: mysqli</title>
   <programlisting role="php">
<![CDATA[
<?php
$mysqli  = new mysqli("localhost", "my_user", "my_password", "world");
$uresult = $mysqli->query("SELECT Name FROM City", MYSQLI_USE_RESULT);

if ($uresult) {
   while ($row = $uresult->fetch_assoc()) {
       echo $row['Name'] . PHP_EOL;
   }
}
$uresult->close();
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Unbuffered query example: pdo_mysql</title>
   <programlisting role="php">
<![CDATA[
<?php
$pdo = new PDO("mysql:host=localhost;dbname=world", 'my_user', 'my_pass');
$pdo->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, TRUE);

$uresult = $pdo->query("SELECT Name FROM City");
if ($uresult) {
   while ($row = $uresult->fetch(PDO::FETCH_ASSOC)) {
       echo $row['Name'] . PHP_EOL;
   }
}
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Unbuffered query example: mysql</title>
   <programlisting role="php">
<![CDATA[
<?php
$conn = mysql_connect("localhost", "my_user", "my_pass");
$db   = mysql_select_db("world");

$uresult = mysql_unbuffered_query("SELECT Name FROM City");
if ($uresult) {
   while ($row = mysql_fetch_assoc($uresult)) {
       echo $row['Name'] . PHP_EOL;
   }
}
?>
]]>
   </programlisting>
  </example>
 </section>

</chapter>
